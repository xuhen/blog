<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        理解js的难点概念 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="https://dn-coding-net-production-static.qbox.me/static/7a51352fa766f4176d7c4543339e0e98.png" />
        </div>
        <div class="name">
            <i>Edward xu</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-history路由和hash路由的区别"><span class="toc-text">Q.history路由和hash路由的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-描述下浏览器缓存机制"><span class="toc-text">Q. 描述下浏览器缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-解释下ajax"><span class="toc-text">Q. 解释下ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-解释下jsonp怎样工作的，为什么它不是ajax"><span class="toc-text">Q. 解释下jsonp怎样工作的，为什么它不是ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-跨域的解决方案"><span class="toc-text">Q. 跨域的解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-“use-strict”-是什么用它有啥利弊。"><span class="toc-text">Q. “use strict”;是什么用它有啥利弊。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-哪些操作会引起浏览器重绘和重排？"><span class="toc-text">Q. 哪些操作会引起浏览器重绘和重排？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-浏览器渲染过程"><span class="toc-text">Q. 浏览器渲染过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-实现bind方法"><span class="toc-text">Q. 实现bind方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-HTTP2-0和HTTP1-X相比的新特性"><span class="toc-text">Q. HTTP2.0和HTTP1.X相比的新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-以浏览器为例解释进程-process-和线程-thread"><span class="toc-text">Q. 以浏览器为例解释进程(process)和线程(thread).</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        理解js的难点概念
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2019-11-17 18:56:28</span></span>
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="Q-history路由和hash路由的区别"><a href="#Q-history路由和hash路由的区别" class="headerlink" title="Q.history路由和hash路由的区别"></a>Q.history路由和hash路由的区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line"><span class="number">1.</span> history路由（怕刷新url）</span><br><span class="line">    流览器新的api History API的引入，现在我们就有<span class="built_in">window</span>.history对象提供的方法去操作流量器访问历史</span><br><span class="line">    <span class="built_in">window</span>.history.back()，<span class="built_in">window</span>.history.forward()，还有<span class="built_in">window</span>.history.pushState()。</span><br><span class="line">    pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。</span><br><span class="line"><span class="number">2.</span> hash路由</span><br><span class="line">    需要监听哈希变化触发的事件 —— hashchange 事件</span><br><span class="line">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(event.oldURL, event.newURL);</span><br><span class="line">     	<span class="keyword">let</span> hash = location.hash.slice(<span class="number">1</span>);</span><br><span class="line">     	<span class="built_in">document</span>.body.style.color = hash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-描述下浏览器缓存机制"><a href="#Q-描述下浏览器缓存机制" class="headerlink" title="Q. 描述下浏览器缓存机制"></a>Q. 描述下浏览器缓存机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">缓存过期时间是根据几个headers来计算的:</span><br><span class="line">1. 如果&quot;Cache-control: max-age=N&quot; 存在，那过期时间就是N</span><br><span class="line">2. 上一个不存在，如果Expires存在，那就是它减去Date header就是过期时间</span><br><span class="line">3. 如果前两都不存在，如果Last-Modified存在，那过期时间就是 (Date - Last-Modified) / 10</span><br><span class="line"></span><br><span class="line">缓存验证：</span><br><span class="line">1. ETags(强验证)： ETag header 是资源响应的一部分，</span><br><span class="line">浏览器可以在以后的请求中加入If-None-Match 去验证缓存资源</span><br><span class="line">2.Last-Modified(协商缓存)：如果在响应请求中有Last-Modified header ，</span><br><span class="line">浏览器可以发起If-Modified-Since请求去验证缓存文件</span><br></pre></td></tr></table></figure>
<h2 id="Q-解释下ajax"><a href="#Q-解释下ajax" class="headerlink" title="Q. 解释下ajax"></a>Q. 解释下ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;url&quot;, true);</span><br><span class="line">xhr.setRequestHeader(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">xhr.onload = function() &#123;</span><br><span class="line">	var data = JSON.parse(xhr.responseText);</span><br><span class="line">	if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
<h2 id="Q-解释下jsonp怎样工作的，为什么它不是ajax"><a href="#Q-解释下jsonp怎样工作的，为什么它不是ajax" class="headerlink" title="Q. 解释下jsonp怎样工作的，为什么它不是ajax"></a>Q. 解释下jsonp怎样工作的，为什么它不是ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">JSON with Padding</span><br><span class="line">AJAX无法跨域是受到“同源策略”的限制，但是带有src属性的标签</span><br><span class="line">    如：&lt;script&gt;, &lt;img&gt; &lt;iframe&gt;是不受该政策限制的。</span><br><span class="line">通常&lt;script&gt;引用静态js其实也可以引用动态资源，后台服务被访问后返回</span><br><span class="line">一个函数调用形式的字符串，由于是字符串，因此在后台不会起到任何作用，</span><br><span class="line">但到前台，就成了函数调用。</span><br><span class="line">优点：兼容性好，能在古老的浏览器上实现</span><br><span class="line">缺点：1. 只能 GET 不能 POST； 2. 二是存在安全隐患，脚本注入</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var dosomething = function(data)&#123;</span><br><span class="line">      console.log(data);</span><br><span class="line">&#125;;</span><br><span class="line">var url = &quot;https://hengxu.gitee.io/json.txt?callback=dosomething&quot;;</span><br><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(script);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">jsonp.txt</span><br><span class="line">dosomething(&#123;</span><br><span class="line">    &quot;data&quot;:&quot;JSONP Works&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Q-跨域的解决方案"><a href="#Q-跨域的解决方案" class="headerlink" title="Q. 跨域的解决方案"></a>Q. 跨域的解决方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目的：同源策略的目的，是为了保证用户信息的安全，防止恶意网站窃取数据。</span><br><span class="line">1. 跨域资源共享（cors）</span><br><span class="line">    * 客户端需要设置xhr属性withCredentials=true</span><br><span class="line">    * 服务器端在response header设置两个字段</span><br><span class="line">        Access-Control-Allow-Origin:domainName | *</span><br><span class="line">	Access-Control-Allow-Credentials:true</span><br><span class="line">2. jsonp</span><br><span class="line">3. 服务器代理: 浏览器有跨域限制，但是服务器不存在跨域问题，</span><br><span class="line">   所以可以由服务器请求所要域的资源再返回给客户端</span><br><span class="line">4. 使用postMessage实现页面之间通信</span><br><span class="line">   * 页面和新开的窗口数据交互</span><br><span class="line">   * 多窗口的数据交互</span><br><span class="line">   * 页面与所嵌套iframe之间的信息传递。</span><br></pre></td></tr></table></figure>
<h2 id="Q-“use-strict”-是什么用它有啥利弊。"><a href="#Q-“use-strict”-是什么用它有啥利弊。" class="headerlink" title="Q. “use strict”;是什么用它有啥利弊。"></a>Q. “use strict”;是什么用它有啥利弊。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">作用：</span><br><span class="line">1. 消除JavaScript语法的不合理、不严谨，减少怪异行为。</span><br><span class="line">2. 消除代码运行的一些不安全之处，保证代码运行安全。</span><br><span class="line">3. 提高编译器效率，增加运行速度。</span><br><span class="line">4. 为未来新版JavaScript做好铺垫。</span><br><span class="line">eg: * 全局变量必须用var显式声明，否则报错。</span><br><span class="line">    * 禁止this关键字指向全局对象</span><br><span class="line">    * 对一个对象的只读属性赋值，会报错。</span><br><span class="line">    * 函数必须声明在顶层</span><br><span class="line">	&quot;use strict&quot;;</span><br><span class="line">	if (true) &#123;</span><br><span class="line">	    function f() &#123; &#125; // 语法错误</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-哪些操作会引起浏览器重绘和重排？"><a href="#Q-哪些操作会引起浏览器重绘和重排？" class="headerlink" title="Q. 哪些操作会引起浏览器重绘和重排？"></a>Q. 哪些操作会引起浏览器重绘和重排？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重绘：屏幕的一部分要重画，比如某个css背景色变了，但是元素的几何尺寸没变。</span><br><span class="line">重排：元素的几何尺寸变了，需要重新验证并计算。</span><br><span class="line">    * 当增加、删除、修改DOM节点时，会导致重绘或重排。</span><br><span class="line">    * 移动DOM位置，或有动画，会有重绘和重排。</span><br><span class="line">    * 修改CSS样式</span><br><span class="line">    * resize窗口</span><br><span class="line">    * 修改网页默认字体，或字体大小。</span><br><span class="line">Note: display: none，会触发重排；visibility: hidden只会触发重绘。</span><br><span class="line">减少重绘或重排：</span><br><span class="line">    * 不要一条一条改DOM的样式，用预定义好的css的class，去修改DOM上的className</span><br><span class="line">    * clone DOM节点到内存里改完后再放到页面。</span><br><span class="line">    * 为动画DOM使用fixed或absolute定位，这样修改CSS就不会引起页面重排了</span><br></pre></td></tr></table></figure>
<h2 id="Q-浏览器渲染过程"><a href="#Q-浏览器渲染过程" class="headerlink" title="Q. 浏览器渲染过程"></a>Q. 浏览器渲染过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">   1. 处理HTML标记并构建DOM树。</span><br><span class="line">   2. 处理CSS标记并构建CSSOM树。</span><br><span class="line">   3. 将DOM与CSSOM合并成一个渲染树。</span><br><span class="line">   4. 根据渲染树来布局，计算每个节点的几何信息。</span><br><span class="line">   5. 将各个节点绘制到屏幕。</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">   * 默认情况下，CSS被视为阻塞渲染的资源，所以浏览器不会渲染任何已处理的内容，直到CSSOM构建完毕。</span><br><span class="line">   * JavaScript 不仅可以读取和修改DOM属性，还可以读取和修改CSSOM属性。</span><br></pre></td></tr></table></figure>
<h2 id="Q-实现bind方法"><a href="#Q-实现bind方法" class="headerlink" title="Q. 实现bind方法"></a>Q. 实现bind方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">Function.prototype.bind = function(context)&#123;</span><br><span class="line">  var args = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">  fn = this;</span><br><span class="line">  return function()&#123;</span><br><span class="line">      var innerArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">      var finalArgs = args.concat(innerArgs);</span><br><span class="line">      return fn.apply(context,finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">eg:</span><br><span class="line">var obj = &#123;</span><br><span class="line">	name: &quot;Edward&quot;,</span><br><span class="line">	age: 25,</span><br><span class="line">	tellInfo: function() &#123;</span><br><span class="line">		setTimeout(function(p1, p2, p3) &#123;</span><br><span class="line">			console.log(p1, p2, p3);</span><br><span class="line">			console.log(this.name, this.age);</span><br><span class="line">		&#125;.bind(this, &quot;hello&quot;, &quot;world&quot;, 23), 0);</span><br><span class="line">	&#125;,</span><br><span class="line">	info: function() &#123;</span><br><span class="line">		return function(p1, p2) &#123;</span><br><span class="line">			console.log(this.name, this.age, p1, p2);</span><br><span class="line">		&#125;.bind(this, &quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-HTTP2-0和HTTP1-X相比的新特性"><a href="#Q-HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="Q. HTTP2.0和HTTP1.X相比的新特性"></a>Q. HTTP2.0和HTTP1.X相比的新特性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 新的二进制格式（Binary Format）HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，</span><br><span class="line">文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。</span><br><span class="line">基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</span><br><span class="line">2. 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。</span><br><span class="line">一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，</span><br><span class="line">接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</span><br><span class="line">3. header压缩。HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</span><br><span class="line">4. 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，</span><br><span class="line">服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</span><br></pre></td></tr></table></figure>
<h2 id="Q-以浏览器为例解释进程-process-和线程-thread"><a href="#Q-以浏览器为例解释进程-process-和线程-thread" class="headerlink" title="Q. 以浏览器为例解释进程(process)和线程(thread)."></a>Q. 以浏览器为例解释进程(process)和线程(thread).</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A.</span><br><span class="line">1. 浏览器设置 UI 渲染线程与 JavaScript 引擎线程为互斥的关系，当 JavaScript 引擎线程执行时 UI 渲染线程会被挂起，</span><br><span class="line">UI 更新会被保存在一个队列中等到 JavaScript 引擎线程空闲时立即被执行。</span><br><span class="line"></span><br><span class="line">前端某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让他们和别的任务一样，都老老实实的排队等待执行的话，</span><br><span class="line">执行效率会非常的低，甚至导致页面的假死。所以浏览器是多线程的，除了之前介绍的两个互斥的呈现引擎和 JavaScript 解释器，</span><br><span class="line">浏览器一般还会实现这几个线程：浏览器事件触发线程，定时触发器线程以及异步 HTTP 请求线程。</span><br><span class="line"></span><br><span class="line">    *浏览器事件触发线程：</span><br><span class="line">	当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</span><br><span class="line">	这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，</span><br><span class="line">	但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理；</span><br><span class="line">    *定时触发器线程：</span><br><span class="line">	浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的,</span><br><span class="line">	如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案；</span><br><span class="line">    *异步 HTTP 请求线程：</span><br><span class="line">	XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，</span><br><span class="line">	异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理；</span><br></pre></td></tr></table></figure>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>
