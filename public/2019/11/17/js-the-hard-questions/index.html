<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="This is the blog page of Edward">
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        理解js的难点概念 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="https://dn-coding-net-production-static.qbox.me/static/7a51352fa766f4176d7c4543339e0e98.png" />
        </div>
        <div class="name">
            <i>Edward xu</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-history路由和hash路由的区别"><span class="toc-text">Q.history路由和hash路由的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-描述下浏览器缓存机制"><span class="toc-text">Q. 描述下浏览器缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-解释下ajax"><span class="toc-text">Q. 解释下ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-解释下jsonp怎样工作的，为什么它不是ajax"><span class="toc-text">Q. 解释下jsonp怎样工作的，为什么它不是ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-跨域的解决方案"><span class="toc-text">Q. 跨域的解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-“use-strict”-是什么用它有啥利弊。"><span class="toc-text">Q. “use strict”;是什么用它有啥利弊。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-哪些操作会引起浏览器重绘和重排？"><span class="toc-text">Q. 哪些操作会引起浏览器重绘和重排？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-浏览器渲染过程"><span class="toc-text">Q. 浏览器渲染过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-实现call方法"><span class="toc-text">Q. 实现call方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-实现bind方法"><span class="toc-text">Q. 实现bind方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-HTTP2-0和HTTP1-X相比的新特性"><span class="toc-text">Q. HTTP2.0和HTTP1.X相比的新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-以浏览器为例解释进程-process-和线程-thread"><span class="toc-text">Q. 以浏览器为例解释进程(process)和线程(thread).</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-前端异常捕获都有哪些方式？"><span class="toc-text">Q. 前端异常捕获都有哪些方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-requestAnimationFrame-和-requestIdleCallback"><span class="toc-text">Q. requestAnimationFrame 和 requestIdleCallback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-模拟new-操作符"><span class="toc-text">Q. 模拟new 操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-格式化现金"><span class="toc-text">Q. 格式化现金</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-Commonjs模块打包到前端"><span class="toc-text">Q. Commonjs模块打包到前端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-动态加载脚本的通用方法"><span class="toc-text">Q. 动态加载脚本的通用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-script标签的defer和async的区别"><span class="toc-text">Q. script标签的defer和async的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS-JS-阻塞-DOM-解析和渲染"><span class="toc-text">CSS/JS 阻塞 DOM 解析和渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uncurrying"><span class="toc-text">uncurrying</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#惰性加载函数"><span class="toc-text">惰性加载函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高阶函数定义"><span class="toc-text">高阶函数定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-的指向"><span class="toc-text">this 的指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM的扩展都增加了哪些内容？"><span class="toc-text">DOM的扩展都增加了哪些内容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存代理实现单例模式"><span class="toc-text">缓存代理实现单例模式</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        理解js的难点概念
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2019-11-17 18:56:28</span></span>
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="Q-history路由和hash路由的区别"><a href="#Q-history路由和hash路由的区别" class="headerlink" title="Q.history路由和hash路由的区别"></a>Q.history路由和hash路由的区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line"><span class="number">1.</span> history路由（怕刷新url）</span><br><span class="line">    流览器新的api History API的引入，现在我们就有<span class="built_in">window</span>.history对象提供的方法去操作流量器访问历史</span><br><span class="line">    <span class="built_in">window</span>.history.back()，<span class="built_in">window</span>.history.forward()，还有<span class="built_in">window</span>.history.pushState()。</span><br><span class="line">    pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。</span><br><span class="line"><span class="number">2.</span> hash路由</span><br><span class="line">    需要监听哈希变化触发的事件 —— hashchange 事件</span><br><span class="line">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">     	<span class="built_in">console</span>.log(event.oldURL, event.newURL);</span><br><span class="line">     	<span class="keyword">let</span> hash = location.hash.slice(<span class="number">1</span>);</span><br><span class="line">     	<span class="built_in">document</span>.body.style.color = hash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-描述下浏览器缓存机制"><a href="#Q-描述下浏览器缓存机制" class="headerlink" title="Q. 描述下浏览器缓存机制"></a>Q. 描述下浏览器缓存机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">缓存过期时间是根据几个headers来计算的:</span><br><span class="line">1. 如果&quot;Cache-control: max-age=N&quot; 存在，那过期时间就是N</span><br><span class="line">2. 上一个不存在，如果Expires存在，那就是它减去Date header就是过期时间</span><br><span class="line">3. 如果前两都不存在，如果Last-Modified存在，那过期时间就是 (Date - Last-Modified) / 10</span><br><span class="line"></span><br><span class="line">缓存验证：</span><br><span class="line">1. ETags(强验证)： ETag header 是资源响应的一部分，</span><br><span class="line">浏览器可以在以后的请求中加入If-None-Match 去验证缓存资源</span><br><span class="line">2.Last-Modified(协商缓存)：如果在响应请求中有Last-Modified header ，</span><br><span class="line">浏览器可以发起If-Modified-Since请求去验证缓存文件</span><br></pre></td></tr></table></figure>
<h2 id="Q-解释下ajax"><a href="#Q-解释下ajax" class="headerlink" title="Q. 解释下ajax"></a>Q. 解释下ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;url&quot;, true);</span><br><span class="line">xhr.setRequestHeader(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">	if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">	  var data = JSON.parse(xhr.responseText);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
<h2 id="Q-解释下jsonp怎样工作的，为什么它不是ajax"><a href="#Q-解释下jsonp怎样工作的，为什么它不是ajax" class="headerlink" title="Q. 解释下jsonp怎样工作的，为什么它不是ajax"></a>Q. 解释下jsonp怎样工作的，为什么它不是ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">JSON with Padding</span><br><span class="line">AJAX无法跨域是受到“同源策略”的限制，但是带有src属性的标签</span><br><span class="line">    如：&lt;script&gt;, &lt;img&gt; &lt;iframe&gt;是不受该政策限制的。</span><br><span class="line">通常&lt;script&gt;引用静态js其实也可以引用动态资源，后台服务被访问后返回</span><br><span class="line">一个函数调用形式的字符串，由于是字符串，因此在后台不会起到任何作用，</span><br><span class="line">但到前台，就成了函数调用。</span><br><span class="line">优点：兼容性好，能在古老的浏览器上实现</span><br><span class="line">缺点：1. 只能 GET 不能 POST； 2. 二是存在安全隐患，脚本注入</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var dosomething = function(data)&#123;</span><br><span class="line">      console.log(data);</span><br><span class="line">&#125;;</span><br><span class="line">var url = &quot;https://hengxu.gitee.io/json.txt?callback=dosomething&quot;;</span><br><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(script);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">jsonp.txt</span><br><span class="line">dosomething(&#123;</span><br><span class="line">    &quot;data&quot;:&quot;JSONP Works&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Q-跨域的解决方案"><a href="#Q-跨域的解决方案" class="headerlink" title="Q. 跨域的解决方案"></a>Q. 跨域的解决方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目的：同源策略的目的，是为了保证用户信息的安全，防止恶意网站窃取数据。</span><br><span class="line">1. 跨域资源共享（cors）</span><br><span class="line">    * 客户端需要设置xhr属性withCredentials=true</span><br><span class="line">    * 服务器端在response header设置两个字段</span><br><span class="line">        Access-Control-Allow-Origin:domainName | *</span><br><span class="line">	Access-Control-Allow-Credentials:true</span><br><span class="line">2. jsonp</span><br><span class="line">3. 服务器代理: 浏览器有跨域限制，但是服务器不存在跨域问题，</span><br><span class="line">   所以可以由服务器请求所要域的资源再返回给客户端</span><br><span class="line">4. 使用postMessage实现页面之间通信</span><br><span class="line">   * 页面和新开的窗口数据交互</span><br><span class="line">   * 多窗口的数据交互</span><br><span class="line">   * 页面与所嵌套iframe之间的信息传递。</span><br></pre></td></tr></table></figure>
<h2 id="Q-“use-strict”-是什么用它有啥利弊。"><a href="#Q-“use-strict”-是什么用它有啥利弊。" class="headerlink" title="Q. “use strict”;是什么用它有啥利弊。"></a>Q. “use strict”;是什么用它有啥利弊。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">作用：</span><br><span class="line">1. 消除JavaScript语法的不合理、不严谨，减少怪异行为。</span><br><span class="line">2. 消除代码运行的一些不安全之处，保证代码运行安全。</span><br><span class="line">3. 提高编译器效率，增加运行速度。</span><br><span class="line">4. 为未来新版JavaScript做好铺垫。</span><br><span class="line">eg: * 全局变量必须用var显式声明，否则报错。</span><br><span class="line">    * 禁止this关键字指向全局对象</span><br><span class="line">    * 对一个对象的只读属性赋值，会报错。</span><br><span class="line">    * 函数必须声明在顶层</span><br><span class="line">	&quot;use strict&quot;;</span><br><span class="line">	if (true) &#123;</span><br><span class="line">	    function f() &#123; &#125; // 语法错误</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-哪些操作会引起浏览器重绘和重排？"><a href="#Q-哪些操作会引起浏览器重绘和重排？" class="headerlink" title="Q. 哪些操作会引起浏览器重绘和重排？"></a>Q. 哪些操作会引起浏览器重绘和重排？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重绘：屏幕的一部分要重画，比如某个css背景色变了，但是元素的几何尺寸没变。</span><br><span class="line">重排：元素的几何尺寸变了，需要重新验证并计算。</span><br><span class="line">    * 当增加、删除、修改DOM节点时，会导致重绘或重排。</span><br><span class="line">    * 移动DOM位置，或有动画，会有重绘和重排。</span><br><span class="line">    * 修改CSS样式</span><br><span class="line">    * resize窗口</span><br><span class="line">    * 修改网页默认字体，或字体大小。</span><br><span class="line">Note: display: none，会触发重排；visibility: hidden只会触发重绘。</span><br><span class="line">减少重绘或重排：</span><br><span class="line">    * 不要一条一条改DOM的样式，用预定义好的css的class，去修改DOM上的className</span><br><span class="line">    * clone DOM节点到内存里改完后再放到页面。</span><br><span class="line">    * 为动画DOM使用fixed或absolute定位，这样修改CSS就不会引起页面重排了</span><br></pre></td></tr></table></figure>
<p>下面说明影响重排的属性<br><img src="http://xuheng.inject.top/images/reflow.png" alt="reflow"></p>
<h2 id="Q-浏览器渲染过程"><a href="#Q-浏览器渲染过程" class="headerlink" title="Q. 浏览器渲染过程"></a>Q. 浏览器渲染过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">   1. 处理HTML标记并构建DOM树。</span><br><span class="line">   2. 处理CSS标记并构建CSSOM树。</span><br><span class="line">   3. 将DOM与CSSOM合并成一个渲染树。</span><br><span class="line">   4. 根据渲染树来布局，计算每个节点的几何信息。</span><br><span class="line">   5. 将各个节点绘制到屏幕。</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">   * 默认情况下，CSS被视为阻塞渲染的资源，所以浏览器不会渲染任何已处理的内容，直到CSSOM构建完毕。</span><br><span class="line">   * JavaScript 不仅可以读取和修改DOM属性，还可以读取和修改CSSOM属性。</span><br></pre></td></tr></table></figure>
<h2 id="Q-实现call方法"><a href="#Q-实现call方法" class="headerlink" title="Q. 实现call方法"></a>Q. 实现call方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myOwnCall = function(someOtherThis) &#123;</span><br><span class="line">  someOtherThis = someOtherThis || global;</span><br><span class="line">  var uniqueID = &quot;00&quot; + Math.random();</span><br><span class="line">  while (someOtherThis.hasOwnProperty(uniqueID)) &#123;</span><br><span class="line">    uniqueID = &quot;00&quot; + Math.random();</span><br><span class="line">  &#125;</span><br><span class="line">  someOtherThis[uniqueID] = this;</span><br><span class="line">  const args = [];</span><br><span class="line">  // arguments are saved in strings, using args</span><br><span class="line">  for (var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(&quot;arguments[&quot; + i + &quot;]&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // strings are reparsed into statements in the eval method</span><br><span class="line">  // Here args automatically calls the Array.toString() method.</span><br><span class="line">  var result = eval(&quot;someOtherThis[uniqueID](&quot; + args + &quot;)&quot;);</span><br><span class="line">  delete someOtherThis[uniqueID];</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Q-实现bind方法"><a href="#Q-实现bind方法" class="headerlink" title="Q. 实现bind方法"></a>Q. 实现bind方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line">Function.prototype.bind = function(context)&#123;</span><br><span class="line">  var args = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">  fn = this;</span><br><span class="line">  return function()&#123;</span><br><span class="line">      var innerArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">      var finalArgs = args.concat(innerArgs);</span><br><span class="line">      return fn.apply(context,finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">eg:</span><br><span class="line">var obj = &#123;</span><br><span class="line">	name: &quot;Edward&quot;,</span><br><span class="line">	age: 25,</span><br><span class="line">	tellInfo: function() &#123;</span><br><span class="line">		setTimeout(function(p1, p2, p3) &#123;</span><br><span class="line">			console.log(p1, p2, p3);</span><br><span class="line">			console.log(this.name, this.age);</span><br><span class="line">		&#125;.bind(this, &quot;hello&quot;, &quot;world&quot;, 23), 0);</span><br><span class="line">	&#125;,</span><br><span class="line">	info: function() &#123;</span><br><span class="line">		return function(p1, p2) &#123;</span><br><span class="line">			console.log(this.name, this.age, p1, p2);</span><br><span class="line">		&#125;.bind(this, &quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-HTTP2-0和HTTP1-X相比的新特性"><a href="#Q-HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="Q. HTTP2.0和HTTP1.X相比的新特性"></a>Q. HTTP2.0和HTTP1.X相比的新特性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 新的二进制格式（Binary Format）HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，</span><br><span class="line">文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。</span><br><span class="line">基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</span><br><span class="line">2. 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。</span><br><span class="line">一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，</span><br><span class="line">接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</span><br><span class="line">3. header压缩。HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</span><br><span class="line">4. 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，</span><br><span class="line">服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</span><br></pre></td></tr></table></figure>
<h2 id="Q-以浏览器为例解释进程-process-和线程-thread"><a href="#Q-以浏览器为例解释进程-process-和线程-thread" class="headerlink" title="Q. 以浏览器为例解释进程(process)和线程(thread)."></a>Q. 以浏览器为例解释进程(process)和线程(thread).</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A.</span><br><span class="line">1. 浏览器设置 UI 渲染线程与 JavaScript 引擎线程为互斥的关系，当 JavaScript 引擎线程执行时 UI 渲染线程会被挂起，</span><br><span class="line">UI 更新会被保存在一个队列中等到 JavaScript 引擎线程空闲时立即被执行。</span><br><span class="line"></span><br><span class="line">前端某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让他们和别的任务一样，都老老实实的排队等待执行的话，</span><br><span class="line">执行效率会非常的低，甚至导致页面的假死。所以浏览器是多线程的，除了之前介绍的两个互斥的呈现引擎和 JavaScript 解释器，</span><br><span class="line">浏览器一般还会实现这几个线程：浏览器事件触发线程，定时触发器线程以及异步 HTTP 请求线程。</span><br><span class="line"></span><br><span class="line">    *浏览器事件触发线程：</span><br><span class="line">	当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</span><br><span class="line">	这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，</span><br><span class="line">	但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理；</span><br><span class="line">    *定时触发器线程：</span><br><span class="line">	浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的,</span><br><span class="line">	如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案；</span><br><span class="line">    *异步 HTTP 请求线程：</span><br><span class="line">	XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，</span><br><span class="line">	异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理；</span><br></pre></td></tr></table></figure>
<h2 id="Q-前端异常捕获都有哪些方式？"><a href="#Q-前端异常捕获都有哪些方式？" class="headerlink" title="Q. 前端异常捕获都有哪些方式？"></a>Q. 前端异常捕获都有哪些方式？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A.</span><br><span class="line">1. 对于一般的同步任务，我们可以使用try...catch</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  undefined.map(v =&gt; v);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(e); // TypeError: Cannot read property &apos;map&apos; of undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 对于setTimeout等异步异常，可以使用window.onerror捕获</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    undefined.map(v =&gt; v);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">window.onerror = (msg, url, row, col, error) =&gt; &#123;</span><br><span class="line">    console.log(&#123; msg, url, row, col, error &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Note: 此方法不能捕获img和css资源的加载异常，比如404；</span><br><span class="line">而window.addEventListener(&apos;error&apos;)方式可以捕获；</span><br><span class="line">addEventListener不能捕获js的异常。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 对于未捕获的Promise异常，可以使用window.onunhandledrejection捕获：</span><br><span class="line"></span><br><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, e =&gt; &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.reject(&apos;promiseError&apos;);</span><br><span class="line"></span><br><span class="line">通过以上的三种捕获方式，我们就可以捕获到我们程序中所有的异常！</span><br><span class="line">注意，如果你的代码是async/await形式的， 可以通过babel转化为Promise的形式，这样</span><br><span class="line">window.onunhandledrejection依然可以捕获到相应的异常。</span><br></pre></td></tr></table></figure>
<h2 id="Q-requestAnimationFrame-和-requestIdleCallback"><a href="#Q-requestAnimationFrame-和-requestIdleCallback" class="headerlink" title="Q. requestAnimationFrame 和 requestIdleCallback"></a>Q. requestAnimationFrame 和 requestIdleCallback</h2><p><img src="http://xuheng.inject.top/images/lifeofaframe.png" alt="reflow"></p>
<h2 id="Q-模拟new-操作符"><a href="#Q-模拟new-操作符" class="headerlink" title="Q. 模拟new 操作符"></a>Q. 模拟new 操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj = new Object(),</span><br><span class="line">        Constructor = [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    var ret = Constructor.apply(obj, arguments);</span><br><span class="line">    return typeof ret === &apos;object&apos; ? ret : obj;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Otaku(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line"></span><br><span class="line">    this.habit = &apos;Games&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength = 60;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName = function () &#123;</span><br><span class="line">    console.log(&apos;I am &apos; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var person = objectFactory(Otaku, &apos;Kevin&apos;, &apos;18&apos;)</span><br><span class="line"></span><br><span class="line">console.log(person.name) // Kevin</span><br><span class="line">console.log(person.habit) // Games</span><br><span class="line">console.log(person.strength) // 60</span><br><span class="line"></span><br><span class="line">person.sayYourName();</span><br></pre></td></tr></table></figure>
<h2 id="Q-格式化现金"><a href="#Q-格式化现金" class="headerlink" title="Q. 格式化现金"></a>Q. 格式化现金</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function format(numberStr) &#123;</span><br><span class="line">    return numberStr.replace(/(\d)(?=(\d&#123;3&#125;)+$)/g, function (mc) &#123;</span><br><span class="line">        console.log(mc)</span><br><span class="line">        return mc + &apos;,&apos;;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(format(&apos;1234567&apos;))</span><br></pre></td></tr></table></figure>
<h2 id="Q-Commonjs模块打包到前端"><a href="#Q-Commonjs模块打包到前端" class="headerlink" title="Q. Commonjs模块打包到前端"></a>Q. Commonjs模块打包到前端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">(function (modules) &#123;</span><br><span class="line">      var installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      function require(moduleName) &#123;</span><br><span class="line">        //如果模块已经导入，那么直接返回它的exports</span><br><span class="line">        if (installedModules[moduleName]) &#123;</span><br><span class="line">          return installedModules[moduleName].exports;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //模块初始化</span><br><span class="line">        var module = installedModules[moduleName] = &#123;</span><br><span class="line">          exports: &#123;&#125;,</span><br><span class="line">          name: moduleName,</span><br><span class="line">          loaded: false</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //执行模块内部的代码，这里的 modules 变量即为我们在上面写好的 modules 对象</span><br><span class="line">        modules[moduleName].call(module.exports, module, module.exports, require);</span><br><span class="line">        //模块导入完成</span><br><span class="line">        module.loaded = true;</span><br><span class="line">        //将模块的exports返回</span><br><span class="line">        return module.exports;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return require(&quot;entry&quot;);</span><br><span class="line">    &#125;)(&#123;</span><br><span class="line">      &quot;entry&quot;: function (module, exports, require, global) &#123;</span><br><span class="line">        //index.js</span><br><span class="line">        var module1 = require(&quot;./module1&quot;);</span><br><span class="line">        var module2 = require(&quot;./module2&quot;);</span><br><span class="line">        module1.foo();</span><br><span class="line">        module2.foo();</span><br><span class="line"></span><br><span class="line">        function hello() &#123;</span><br><span class="line">          console.log(&quot;Hello!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        module.exports = hello;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;./module1&quot;: function (module, exports, require, global) &#123;</span><br><span class="line">        var module2 = require(&quot;./module2&quot;);</span><br><span class="line">        console.log(&quot;initialize module1&quot;);</span><br><span class="line"></span><br><span class="line">        console.log(&quot;this is module2.foo() in module1:&quot;);</span><br><span class="line">        module2.foo();</span><br><span class="line">        console.log(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">        module.exports = &#123;</span><br><span class="line">          foo: function () &#123;</span><br><span class="line">            console.log(&quot;module1 foo !!!&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &quot;./module2&quot;: function (module, exports, require, global) &#123;</span><br><span class="line">        console.log(&quot;initialize module2&quot;);</span><br><span class="line">        module.exports = &#123;</span><br><span class="line">          foo: function () &#123;</span><br><span class="line">            console.log(&quot;module2 foo !!!&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>Q. 关于js函数中this的指向问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. 我们知道，this 对象是在运行时基于函数的执行环境绑定的: 在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象</span><br><span class="line">2. 匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。但有时候 由于编写闭包的方式不同，这一点可能不会那么明显。</span><br><span class="line"></span><br><span class="line">下面来看一个例子:</span><br><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">  name: &quot;My Object&quot;,</span><br><span class="line">  getNameFunc: function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object.getNameFunc()());  //&quot;The Window&quot;(在非严格模式下)</span><br><span class="line"></span><br><span class="line">为什么匿名函数没 有取得其包含作用域(或外部作用域)的 this 对象呢?</span><br><span class="line"></span><br><span class="line">答： 每个函数在被调用时都会自动取得两个特殊变量:this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</span><br><span class="line">  不过，把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了</span><br><span class="line"></span><br><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name: &quot;My Object&quot;,</span><br><span class="line">    getNameFunc: function () &#123;</span><br><span class="line">      var that = this;</span><br><span class="line">      return function () &#123;</span><br><span class="line">        return that.name;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Q. 获取嵌套对象的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function get(o, path) &#123;</span><br><span class="line">    var paths = path.split(/[.[\],]/).filter(Boolean);</span><br><span class="line">    return paths.reduce((ac, cur) =&gt; &#123;</span><br><span class="line">        return (ac &amp;&amp; ac[cur] !== &apos;undefined&apos;) ? ac[cur] : undefined;</span><br><span class="line">    &#125;, o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: 1</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        d: [</span><br><span class="line">            &#123;</span><br><span class="line">                e: 1,</span><br><span class="line">                f: 2</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var r = get(obj, &apos;a.d[0].e&apos;);</span><br><span class="line"></span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure>
<p>Q. js中的数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 简单类型</span><br><span class="line"></span><br><span class="line">var a = undefined;</span><br><span class="line">var b = 12;</span><br><span class="line">var c = true;</span><br><span class="line">var d = &apos;&apos;;</span><br><span class="line">var e = function () &#123; &#125;</span><br><span class="line">var f = &#123;&#125;;</span><br><span class="line">var g = Symbol();</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">    typeof a,</span><br><span class="line">    typeof b,</span><br><span class="line">    typeof c,</span><br><span class="line">    typeof d,</span><br><span class="line">    typeof e,</span><br><span class="line">    typeof f,</span><br><span class="line">    typeof g,</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// undefined number boolean string function object symbol</span><br><span class="line"></span><br><span class="line">2. 复杂类型</span><br><span class="line">Object</span><br></pre></td></tr></table></figure>
<h2 id="Q-动态加载脚本的通用方法"><a href="#Q-动态加载脚本的通用方法" class="headerlink" title="Q. 动态加载脚本的通用方法"></a>Q. 动态加载脚本的通用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function loadScript(url)&#123;</span><br><span class="line">  var script = document.createElement(&quot;script&quot;); </span><br><span class="line">  script.type = &quot;text/javascript&quot;;</span><br><span class="line">  script.src = url; </span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(&quot;client.js&quot;);</span><br><span class="line"></span><br><span class="line">function loadScriptString(code) &#123;</span><br><span class="line">  var script = document.createElement(&quot;script&quot;);</span><br><span class="line">  script.type = &quot;text/javascript&quot;;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    // IE可能报错</span><br><span class="line">    script.appendChild(document.createTextNode(code));</span><br><span class="line">  &#125; catch (ex) &#123;</span><br><span class="line">    // 在IE中</span><br><span class="line">    script.text = code;</span><br><span class="line">  &#125;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScriptString(&quot;function sayHi()&#123;alert(&apos;hi&apos;);&#125;&quot;);</span><br><span class="line">sayHi()</span><br><span class="line"></span><br><span class="line">function loadStyles(url) &#123;</span><br><span class="line">  var link = document.createElement(&quot;link&quot;);</span><br><span class="line">  link.rel = &quot;stylesheet&quot;;</span><br><span class="line">  link.type = &quot;text/css&quot;;</span><br><span class="line">  link.href = url;</span><br><span class="line">  var head = document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">  head.appendChild(link);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">loadStyles(&quot;style.css&quot;);</span><br><span class="line"></span><br><span class="line">function loadStyleString(css) &#123;</span><br><span class="line">  var style = document.createElement(&quot;style&quot;);</span><br><span class="line">  style.type = &quot;text/css&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">    // IE可能报错</span><br><span class="line">    style.appendChild(document.createTextNode(css));</span><br><span class="line">  &#125; catch (ex) &#123;</span><br><span class="line">    // IE中的fallback</span><br><span class="line">    style.styleSheet.cssText = css;</span><br><span class="line">  &#125;</span><br><span class="line">  var head = document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">  head.appendChild(style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadStyleString(&quot;body&#123;background-color:red&#125;&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="Q-script标签的defer和async的区别"><a href="#Q-script标签的defer和async的区别" class="headerlink" title="Q. script标签的defer和async的区别"></a>Q. script标签的defer和async的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">两者都会并行下载，不会影响页面的解析。</span><br><span class="line"></span><br><span class="line">defer 会按照顺序在 DOMContentLoaded 前按照页面出现顺序依次执行。</span><br><span class="line"></span><br><span class="line">async 当脚本下载完后立即执行。（两者执行顺序不确定，执行阶段不确定，可能在 DOMContentLoaded 事件前或者后 ）</span><br></pre></td></tr></table></figure>
<p><img src="http://xuheng.inject.top/images/defer.jpg" alt="reflow"></p>
<h2 id="CSS-JS-阻塞-DOM-解析和渲染"><a href="#CSS-JS-阻塞-DOM-解析和渲染" class="headerlink" title="CSS/JS 阻塞 DOM 解析和渲染"></a>CSS/JS 阻塞 DOM 解析和渲染</h2><p><a href="https://harttle.land/2016/11/26/static-dom-render-blocking.html" target="_blank" rel="noopener">https://harttle.land/2016/11/26/static-dom-render-blocking.html</a></p>
<h2 id="uncurrying"><a href="#uncurrying" class="headerlink" title="uncurrying"></a>uncurrying</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.uncurrying = function () &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var obj = Array.prototype.shift.call(arguments);</span><br><span class="line">        return self.apply(obj, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (var i = 0, fn, ary = [&apos;push&apos;, &apos;shift&apos;, &apos;forEach&apos;]; fn = ary[i++];) &#123;</span><br><span class="line">    Array[fn] = Array.prototype[fn].uncurrying();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    &quot;length&quot;: 3,</span><br><span class="line">    &quot;0&quot;: 1,</span><br><span class="line">    &quot;1&quot;: 2,</span><br><span class="line">    &quot;2&quot;: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array.push(obj, 4);</span><br><span class="line">console.log(obj.length);</span><br><span class="line"></span><br><span class="line">var first = Array.shift(obj); // 截取第一个元素</span><br><span class="line">console.log(first); // 输出:1</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">Array.forEach(obj, function (i, n) &#123;</span><br><span class="line">    console.log(i, n); // 分别输出:0, 1, 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="惰性加载函数"><a href="#惰性加载函数" class="headerlink" title="惰性加载函数"></a>惰性加载函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var addEvent = function (elem, type, handler) &#123;</span><br><span class="line">  if (window.addEventListener) &#123;</span><br><span class="line">    addEvent = function (elem, type, handler) &#123;</span><br><span class="line">      elem.addEventListener(type, handler, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (window.attachEvent) &#123;</span><br><span class="line">    addEvent = function (elem, type, handler) &#123;</span><br><span class="line">      elem.attachEvent(&apos;on&apos; + type, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addEvent(elem, type, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var btn = document.getElementById(&apos;execute&apos;)</span><br><span class="line"></span><br><span class="line">addEvent(btn, &apos;click&apos;, function () &#123;</span><br><span class="line">  console.log(&apos;click&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数定义"><a href="#高阶函数定义" class="headerlink" title="高阶函数定义"></a>高阶函数定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 函数可以作为参数被传递;</span><br><span class="line">2. 函数可以作为返回值输出。</span><br></pre></td></tr></table></figure>
<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this 的指向分4种</span><br><span class="line"></span><br><span class="line">1. 作为对象的方法调用</span><br><span class="line">2. 作为普通函数调用</span><br><span class="line">3. 构造器调用</span><br><span class="line">4. Function.prototype.call 和 Function.prototype.apply 调用</span><br></pre></td></tr></table></figure>
<h2 id="DOM的扩展都增加了哪些内容？"><a href="#DOM的扩展都增加了哪些内容？" class="headerlink" title="DOM的扩展都增加了哪些内容？"></a>DOM的扩展都增加了哪些内容？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 选择符api: querySelector, querySelectorAll</span><br><span class="line">2. 元素遍历的属性:</span><br><span class="line">    - childElementCount</span><br><span class="line">    - firstElementChild</span><br><span class="line">    - lastElementChild</span><br><span class="line">    - previousElementSibling</span><br><span class="line">    - nextElementSibling</span><br></pre></td></tr></table></figure>
<h2 id="缓存代理实现单例模式"><a href="#缓存代理实现单例模式" class="headerlink" title="缓存代理实现单例模式"></a>缓存代理实现单例模式</h2><p>单例模式的核心是确保只有一个实例，并提供全局访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var CreateDiv = function (html) &#123;</span><br><span class="line">    this.html = html;</span><br><span class="line">    this.init();</span><br><span class="line">&#125;;</span><br><span class="line">CreateDiv.prototype.init = function () &#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;;</span><br><span class="line">var ProxySingletonCreateDiv = (function () &#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return function (html) &#123;</span><br><span class="line">        if (!instance) &#123;</span><br><span class="line">            instance = new CreateDiv(html);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">var a = new ProxySingletonCreateDiv(&apos;sven1&apos;);</span><br><span class="line">var b = new ProxySingletonCreateDiv(&apos;sven2&apos;);</span><br></pre></td></tr></table></figure>
<p>通用惰性单例函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var getSingle = function (fn) &#123;</span><br><span class="line">  var result;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return result || (result = fn.apply(this, arguments));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var createLoginLayer = function () &#123;</span><br><span class="line">  var div = document.createElement(&apos;div&apos;);</span><br><span class="line">  div.innerHTML = &apos;我是登录浮窗&apos;;</span><br><span class="line">  div.style.display = &apos;none&apos;;</span><br><span class="line">  document.body.appendChild(div);</span><br><span class="line">  return div;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;loginBtn&apos;).onclick = function () &#123;</span><br><span class="line">  var loginLayer = createSingleLoginLayer();</span><br><span class="line">  loginLayer.style.display = &apos;block&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>
